#include "sass.hpp"
#include "ast.hpp"
#include "environment.hpp"

namespace Sass {

  template <typename T>
  Environment<T>::Environment(bool is_shadow)
  : local_frame_(environment_map<std::string, T>()),
    parent_(0), is_shadow_(false)
  { }
  template <typename T>
  Environment<T>::Environment(Environment<T>* env, bool is_shadow)
  : local_frame_(environment_map<std::string, T>()),
    parent_(env), is_shadow_(is_shadow)
  { }
  template <typename T>
  Environment<T>::Environment(Environment<T>& env, bool is_shadow)
  : local_frame_(environment_map<std::string, T>()),
    parent_(&env), is_shadow_(is_shadow)
  { }

  // link parent to create a stack
  template <typename T>
  void Environment<T>::link(Environment& env) { parent_ = &env; }
  template <typename T>
  void Environment<T>::link(Environment* env) { parent_ = env; }

  // this is used to find the global frame
  // which is the second last on the stack
  template <typename T>
  bool Environment<T>::is_lexical() const
  {
    return !! parent_ && parent_->parent_;
  }

  // only match the real root scope
  // there is still a parent around
  // not sure what it is actually use for
  // I guess we store functions etc. there
  template <typename T>
  bool Environment<T>::is_global() const
  {
    return parent_ && ! parent_->parent_;
  }

  template <typename T>
  environment_map<std::string, T>& Environment<T>::local_frame() {
    return local_frame_;
  }

  template <typename T>
  bool Environment<T>::has_local(const std::string& key) const
  { return local_frame_.find(key) != local_frame_.end(); }

  template <typename T> EnvResult
  Environment<T>::find_local(const std::string& key)
  {
    auto end = local_frame_.end();
    auto it = local_frame_.find(key);
    return EnvResult(it, it != end);
  }

  template <typename T>
  T& Environment<T>::get_local(const std::string& key)
  { return local_frame_[key]; }

  template <typename T>
  void Environment<T>::set_local(const std::string& key, const T& val)
  {
    local_frame_[key] = val;
  }
  template <typename T>
  void Environment<T>::set_local(const std::string& key, T&& val)
  {
    local_frame_[key] = val;
  }

  template <typename T>
  void Environment<T>::del_local(const std::string& key)
  { local_frame_.erase(key); }

  template <typename T>
  Environment<T>* Environment<T>::global_env()
  {
    Environment* cur = this;
    while (cur->is_lexical()) {
      cur = cur->parent_;
    }
    return cur;
  }

  template <typen