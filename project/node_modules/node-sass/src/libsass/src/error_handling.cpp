#include "sass.hpp"
#include "ast.hpp"
#include "prelexer.hpp"
#include "backtrace.hpp"
#include "error_handling.hpp"

#include <iostream>

namespace Sass {

  namespace Exception {

    Base::Base(ParserState pstate, std::string msg, Backtraces traces)
    : std::runtime_error(msg), msg(msg),
      prefix("Error"), pstate(pstate), traces(traces)
    { }

    InvalidSass::InvalidSass(ParserState pstate, Backtraces traces, std::string msg)
    : Base(pstate, msg, traces)
    { }


    InvalidParent::InvalidParent(Selector_Ptr parent, Backtraces traces, Selector_Ptr selector)
    : Base(selector->pstate(), def_msg, traces), parent(parent), selector(selector)
    {
      msg = "Invalid parent selector for \"";
      msg += selector->to_string(Sass_Inspect_Options());
      msg += "\": \"";
      msg += parent->to_string(Sass_Inspect_Options());
      msg += "\"";
    }

    InvalidVarKwdType::InvalidVarKwdType(ParserState pstate, Backtraces traces, std::string name, const Argument_Ptr arg)
    : Base(pstate, def_msg, traces), name(name), arg(arg)
    {
      msg = "Variable keyword argument map must have string keys.\n";
      msg += name + " is not a string in " + arg->to_string() + ".";
    }

    InvalidArgumentType::InvalidArgumentType(ParserState pstate, Backtraces traces, std::string fn, std::string arg, std::string type, const Value_Ptr value)
    : Base(pstate, def_msg, traces), fn(fn), arg(arg), type(type), value(value)
    {
      msg  = arg + ": \"";
      if (value) msg += value->to_string(Sass_Inspect_Options());
      msg += "\" is not a " + type;
      msg += " for `" + fn + "'";
    }

    MissingArgument::MissingArgument(ParserState pstate, Backtraces traces, std::string fn, std::string arg, std::string fntype)
    : Base(pstate, def_msg, traces), fn(fn), arg(arg), fntype(fntype)
    {
      msg  = fntype + " " + fn;
      msg += " is missing argument ";
      msg += arg + ".";
    }

    InvalidSyntax::InvalidSyntax(ParserState pstate, Backtraces traces, std::string msg)
    : Base(pstate, msg, traces)
    { }

    NestingLimitError::NestingLimitError(ParserState pstate, Backtraces traces, std::string msg)
    : Base(pstate, msg, traces)
    { }

    DuplicateKeyError::DuplicateKeyError(Backtraces traces, const Map& dup, const Expression& org)
    : Base(org.pstate(), def_msg, traces), dup(dup), org(org)
    {
      msg  = "Duplicate key ";
      msg += dup.get_duplicate_key()->inspect();
      msg += " in map (";
      msg += org.inspect();
      msg += ").";
    }

    TypeMismatch::TypeMismatch(Backtraces traces, const Expression& var, const std::string type)
    : Base(var.pstate(), def_msg, traces), var(var), type(type)
    {
      msg  = var.to_string();
      msg += " is not an ";
      msg += type;
      msg += ".";
    }

    InvalidValue::InvalidValue(Backtraces traces, const Expression& val)
    : Base(val.pstate(), def_msg, traces), val(val)
    {
      msg  = val.to_string();
      msg += " isn't a valid CSS value.";
    }

    StackError::StackError(Backtraces traces, const AST_Node& node)
    : Base(node.pstate(), def_msg, traces), node(node)
    {
      msg  = "stack level too deep";
    }

    IncompatibleUnits::IncompatibleUnits(const Units& lhs, const Units& rhs)
    {
      msg  = "Incompatible units: '";
      msg += rhs.unit();
      msg += "' and '";
      msg += lhs.unit();
      msg += "'.";
    }

    IncompatibleUnits::IncompatibleUnits(const UnitType lhs, const UnitType rhs)
    {
      msg  = "Incompatible units: '";
      msg += unit_to_string(rhs);
      msg += "' and '";
      msg += unit_to_string(lhs);
      msg += "'.";
    }

    AlphaChannelsNotEqual::AlphaChannelsNotEqual(Expression_Ptr_Const lhs, Expression_Ptr_Const rhs, enum Sass_OP op)
    : OperationError(), lhs(lhs), rhs(rhs), op(op)
    {
      msg  = "Alpha channels must be equal: ";
      msg += lhs->to_string({ NESTED, 5 });
      msg += " " + sass_op_to_name(op) + " ";
      msg += rhs->to_string({ NESTED, 5 });
      msg +