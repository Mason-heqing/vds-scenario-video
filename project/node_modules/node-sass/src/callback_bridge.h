#ifndef CALLBACK_BRIDGE_H
#define CALLBACK_BRIDGE_H

#include <vector>
#include <nan.h>
#include <algorithm>
#include <uv.h>

#define COMMA ,

template <typename T, typename L = void*>
class CallbackBridge {
  public:
    CallbackBridge(v8::Local<v8::Function>, bool);
    virtual ~CallbackBridge();

    // Executes the callback
    T operator()(std::vector<void*>);

  protected:
    // We will expose a bridge object to the JS callback that wraps this instance so we don't loose context.
    // This is the V8 constructor for such objects.
    static Nan::MaybeLocal<v8::Function> get_wrapper_constructor();
    static void async_gone(uv_handle_t *handle);
    static NAN_METHOD(New);
    static NAN_METHOD(ReturnCallback);
    static Nan::Persistent<v8::Function> wrapper_constructor;
    Nan::Persistent<v8::Object> wrapper;

    // The callback that will get called in the main thread after the worker thread used for the sass
    // compilation step makes a call to uv_async_send()
    static void dispatched_async_uv_callback(uv_async_t*);

    // The V8 values sent to our ReturnCallback must be read on the main thread not the sass worker thread.
    // This gives a chance to specialized subclasses to transform those values into whatever makes sense to
    // sass before we resume the worker thread.
    virtual T post_process_return_value(v8::Local<v8::Value>) const =0;


    virtual std::vector<v8::Local<v8::Value>> pre_process_args(std::vector<L>) const =0;

    Nan::Callback* callback;
    Nan::AsyncResource* async_resource;
    bool is_sync;

    uv_mutex_t cv_mutex;
    uv_cond_t condition_variable;
    uv_async_t *async;
    std::vector<L> argv;
    bool has_returned;
    T return_value;
};

template <typename T, typename L>
Nan::Persistent<v8::Function> CallbackBridge<T, L>::wrapper_constructor;

template <typename T, typename L>
CallbackBridge<T, L>::CallbackBridge(v8::Local<v8::Function> callback, bool is_sync) : callback(new Nan::Callback(callback)), is_sync(is_sync) {
  /*
   * This is invoked from the main JavaScript thread.
   * V8 context is available.
   */
  Nan::HandleScope scope;
  uv_mutex_init(&this->cv_mutex);
  uv_cond_init(&this->condition_variable);
  if (!is_sync) {
    this->async = new uv_async_t;
    this->async->data = (void*) this;
    uv_async_init(uv_default_loop(), this->async, (uv_async_cb) dispatched_async_uv_callback);
    this->async_resource = new Nan::AsyncResource("node-sass:CallbackBridge");
  }

  v8::Local<v8::Function> func = CallbackBridge<T, L>::get_wrapper_constructor().ToLocalChecked();
  wrapper.Reset(Nan::NewInstance(func).ToLocalChecked());
  Nan::SetInternalFieldPointer(Nan::New(wrapper), 0, this);
}

template <typename T, typename L>
CallbackBridge<T, L>::~CallbackBridge() {
  delete this->callback;
  this->wrapper.Reset();
  uv_cond_destroy(&this->condition_variable);
  uv_mutex_destroy(&this->cv_mutex);

  if (!is_sync) {
    uv_close((uv_handle_t*)this->async, &async_gone);
    delete this->async_resource;
  }
}

template <typename T, typename L>
T CallbackBridge<T, 